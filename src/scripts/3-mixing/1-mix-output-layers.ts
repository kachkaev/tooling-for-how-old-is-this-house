import tilebelt from "@mapbox/tilebelt";
import * as turf from "@turf/turf";
import chalk from "chalk";
import fs from "fs-extra";
import path from "node:path";
import sortKeys from "sort-keys";

import { deepClean } from "../../shared/deep-clean";
import {
  addBufferToBbox,
  calculatePointDistanceToPolygonInMeters,
  deriveBboxCenter,
  isPointInBbox,
  unionBboxes,
} from "../../shared/helpers-for-geometry";
import { writeFormattedJson } from "../../shared/helpers-for-json";
import { getSourcesDirPath } from "../../shared/helpers-for-paths";
import { ScriptError } from "../../shared/helpers-for-scripts";
import {
  ensureTerritoryGitignoreContainsMixing,
  getMixedOutputLayersFilePath,
  MixedOutputLayersFeature,
  PropertyVariant,
  PropertyVariantWithNulls,
} from "../../shared/mixing";
import {
  getOutputLayerFileName,
  OutputLayer,
  OutputLayerProperties,
} from "../../shared/output-layers";
import { processFiles } from "../../shared/process-files";
import {
  getTerritoryDirPath,
  getTerritoryExtent,
} from "../../shared/territory";
import { processTiles } from "../../shared/tiles";

const output = process.stdout;

const bufferSizeInMeters = 7;
const tileZoom = 15;

interface BaseLayerProperties extends OutputLayerProperties {
  id: string;
}
type BaseLayerFeature = turf.Feature<
  turf.Polygon | turf.MultiPolygon,
  BaseLayerProperties
> & {
  bbox: turf.BBox;
  bboxCenter: [x: number, y: number];
  bboxWithBuffer: turf.BBox;
};

interface BaseLayer {
  features: BaseLayerFeature[];
  source: string;
  hash: string;
}

interface PatchLayerFeatureProperties extends BaseLayerProperties {
  derivedBuildArea?: number;
}

type PatchLayerFeature = turf.Feature<
  turf.Point,
  PatchLayerFeatureProperties
> & {
  bbox?: never;
};

interface PatchLayer {
  features: PatchLayerFeature[];
  source: string;
  hash: string;
}

let autogeneratedIdCount = 0;

const generateId = (): string => {
  autogeneratedIdCount += 1;

  return `autogenerated-${autogeneratedIdCount}`;
};

const buildGlobalFeatureId = (
  featureSource: string,
  featureIdProperty: string,
) => `${featureSource}|${featureIdProperty}`;

const usedIds = new Set<string>();

const ensureUniqueIdProperty = (
  properties: OutputLayerProperties,
  source: string,
): BaseLayerProperties => {
  let id = `${properties.id || generateId()}`;
  while (usedIds.has(buildGlobalFeatureId(source, id))) {
    output.write(
      chalk.yellow(
        `Found duplicate id: ${source} → ${id}. An autogenerated id will be used to avoid incorrect mixing of property variants.\n`,
      ),
    );
    id = generateId();
  }

  usedIds.add(buildGlobalFeatureId(source, id));

  return { ...properties, id };
};

const generateCommentWithMixedFeatures = (count: number) =>
  `mixed features: ${count.toString().padStart(3, " ")}`;

const cleanPropertyVariant = (x: PropertyVariantWithNulls): PropertyVariant =>
  sortKeys(deepClean(x));

const script = async () => {
  output.write(chalk.bold("Mixing output layers\n"));

  const baseLayers: BaseLayer[] = [];
  const patchLayers: PatchLayer[] = [];

  const relativeSourcesDirPath = path.relative(
    getTerritoryDirPath(),
    getSourcesDirPath(),
  );

  await processFiles({
    output,
    fileSearchPattern: [
      `${relativeSourcesDirPath}/manual/*.geojson`,
      `${relativeSourcesDirPath}/*/${getOutputLayerFileName()}`,
    ],
    fileSearchDirPath: getTerritoryDirPath(),
    filesNicknameToLog: "output layers",
    processFile: async (filePath, prefixLength) => {
      const prefix = " ".repeat(prefixLength + 1);

      const source = path.basename(path.dirname(filePath));
      output.write(`${prefix}source: ${chalk.cyan(source)}\n`);

      const outputLayer = (await fs.readJson(filePath)) as OutputLayer;

      const layerRole = outputLayer.layerRole as unknown;
      if (layerRole !== "base" && layerRole !== "patch") {
        output.write(
          `${prefix}layer role: ${chalk.red(
            layerRole,
          )} (expected ‘base’ or ‘patch’, skipping)\n`,
        );

        return;
      }
      output.write(`${prefix}layer role: ${chalk.cyan(layerRole)}\n`);

      const knownAt = outputLayer.knownAt;
      output.write(`${prefix}known at: ${chalk.cyan(knownAt ?? "no date")}\n`);

      const totalFeatureCount = outputLayer.features.length;
      output.write(
        `${prefix}total features: ${chalk.cyan(totalFeatureCount)}\n`,
      );

      const logPickedFeatures = (geometryTypes: string, featureCount: number) =>
        output.write(
          `${prefix}picked features (${geometryTypes}): ${chalk.cyan(
            featureCount,
          )}${
            totalFeatureCount > 0
              ? ` (${Math.round((featureCount / totalFeatureCount) * 100)}%)`
              : ""
          }\n`,
        );

      if (layerRole === "base") {
        const features: BaseLayerFeature[] = outputLayer.features.flatMap(
          (feature): BaseLayerFeature[] => {
            const geometry = feature.geometry;
            if (
              !geometry ||
              (geometry.type !== "Polygon" && geometry.type !== "MultiPolygon")
            ) {
              return [];
            }

            const bbox = turf.bbox(feature);

            return [
              {
                bbox,
                bboxCenter: deriveBboxCenter(bbox),
                bboxWithBuffer: addBufferToBbox(bbox, bufferSizeInMeters),
                geometry,
                properties: ensureUniqueIdProperty(feature.properties, source),
                type: feature.type,
              },
            ];
          },
        );

        logPickedFeatures("polygons and multipolygons", features.length);

        baseLayers.push({
          source,
          features,
          hash: `${knownAt ?? totalFeatureCount}`,
        });
      } else {
        const features: PatchLayerFeature[] = [];
        for (const feature of outputLayer.features) {
          const geometry = feature.geometry;
          if (!geometry) {
            continue;
          }

          const derivedBuildArea = Math.round(turf.area(geometry));

          features.push({
            type: "Feature",
            geometry: turf.pointOnFeature(geometry).geometry,
            properties: {
              ...ensureUniqueIdProperty(feature.properties, source),
              ...(derivedBuildArea > 0 ? { derivedBuildArea } : {}),
            },
          });
        }

        logPickedFeatures("convertible to points", features.length);

        patchLayers.push({
          source,
          features,
          hash: `${knownAt ?? totalFeatureCount}`,
        });
      }
    },
  });

  if (baseLayers.length === 0) {
    throw new ScriptError(
      `No base layers found. Have you called all ‘generate-output-layer’ scripts?`,
    );
  }

  const mixedFeatures: MixedOutputLayersFeature[] = [];

  const territoryExtent = await getTerritoryExtent();
  await processTiles({
    territoryExtent,
    preserveOutput: false,
    initialZoom: tileZoom,
    maxAllowedZoom: tileZoom,
    output,
    processTile: (tile) => {
      const tileBbox = tilebelt.tileToBBOX(tile) as turf.BBox;

      const filteredBaseLayers: BaseLayer[] = baseLayers.map((baseLayer) => ({
        ...baseLayer,
        features: baseLayer.features.filter((baseLayerFeature) =>
          isPointInBbox(baseLayerFeature.bboxCenter, tileBbox),
        ),
      }));

      const bboxWithBufferAroundBuildings = (() => {
        let result: turf.BBox | undefined;
        for (const filteredBaseLayer of filteredBaseLayers) {
          for (const baseLayerFeature of filteredBaseLayer.features) {
            result = !result
              ? baseLayerFeature.bboxWithBuffer
              : unionBboxes(result, baseLayerFeature.bboxWithBuffer);
          }
        }

        return result;
      })();

      if (!bboxWithBufferAroundBuildings) {
        return {
          cacheStatus: "used",
          tileStatus: "complete",
          comment: generateCommentWithMixedFeatures(0),
        };
      }

      const originalMixedFeatureCount = mixedFeatures.length;

      const filteredMixinLayers: PatchLayer[] = patchLayers.map(
        (mixinLayer) => ({
          ...mixinLayer,
          features: mixinLayer.features.filter((feature) =>
            isPointInBbox(
              feature.geometry.coordinates,
              bboxWithBufferAroundBuildings,
            ),
          ),
        }),
      );

      for (const filteredBaseLayer of filteredBaseLayers) {
        for (const baseLayerFeature of filteredBaseLayer.features) {
          const propertiesVariants: PropertyVariant[] = [
            cleanPropertyVariant({
              ...baseLayerFeature.properties,
              derivedBuildArea: Math.round(turf.area(baseLayerFeature)),
              distance: 0,
              source: filteredBaseLayer.source,
            }),
          ];

          for (const filteredMixinLayer of filteredMixinLayers) {
            for (const mixinLayerFeature of filteredMixinLayer.features) {
              if (
                !isPointInBbox(
                  mixinLayerFeature.geometry.coordinates,
                  baseLayerFeature.bboxWithBuffer,
                )
              ) {
                continue;
              }

              const distance = Math.max(
                0,
                Math.round(
                  calculatePointDistanceToPolygonInMeters(
                    mixinLayerFeature.geometry,
                    baseLayerFeature,
                  ) * 100,
                ) / 100,
              );

              if (distance <= bufferSizeInMeters) {
                propertiesVariants.push(
                  cleanPropertyVariant({
                    ...mixinLayerFeature.properties,
                    source: filteredMixinLayer.source,
                    distance,
                  }),
                );
              }
            }
          }

          const geometrySource = filteredBaseLayer.source;

          mixedFeatures.push(
            turf.feature(baseLayerFeature.geometry, {
              geometrySource,
              geometryId: baseLayerFeature.properties.id,
              variants: propertiesVariants,
            }),
          );
        }
      }

      return {
        cacheStatus: "notUsed",
        tileStatus: "complete",
        comment: generateCommentWithMixedFeatures(
          mixedFeatures.length - originalMixedFeatureCount,
        ),
      };
    },
  });

  output.write(chalk.green(`Saving...`));

  await ensureTerritoryGitignoreContainsMixing();

  const resultFileName = getMixedOutputLayersFilePath();
  const mixedFeatureCollection = turf.featureCollection(mixedFeatures);
  await writeFormattedJson(resultFileName, mixedFeatureCollection);

  output.write(` Result saved to ${chalk.magenta(resultFileName)}\n`);
};

await script();
